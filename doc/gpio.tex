\section{GPIO}

Если вы читаете этот текст, то, скорее всего, вы знаете, что такое GPIO, поэтому
оставим предысторию и перейдем к делу. В ядре Linux существует два базовых
интерфейса для работы с GPIO\footnote{Мы говорим об использовании уже доступных
ядру GPIO, как сделать GPIO доступными ядру - отдельный вопрос, на котором мы
не будем останавливаться. Просто считайте, что нужный драйвер уже включен в
ядро.}. Первый из них называют legacy - вы просто алоцируете GPIO с заданным
номером используя функцию \emph{gpio\_request}. Далее работаете с ним используя
одну из функций с префиксом \emph{gpio} и когда закончите вам требуется
освободить GPIO вызвав \emph{gpio\_free}.

Для нашего простого примера такого интерфейса вполне достаточно, однако в
реальных приложениях с таким интерфейсом может быть связано несколько проблем.
Например, код драйвера каким-то образом должен знать какой именно номер GPIO
он должен использовать. Соответственно, вы должны предусмотреть возможность
передать в драйвер соответствующий номер. Все кто используют этот драйвер,
должны будут загрузить его с правильными параметрами именно для определенного
оборудования и конфигурации. Но зачем придумывать какие-то новые интерфейсы,
если у нас уже есть DT? Мы можем прямо в DT описать, какими GPIO пользуется то
или иное устройство\footnote{Впрочем теперь, мы не можем просто выгрузить модуль
и загрузить его с другими параметрами, без перезагрузки всей системы, чтобы
переключиться на другой GPIO.}.

Новый интерфейс, о котором мы и будем говорить, использует описание в DT.
Соответственно, вы должны в DT добавить к описанию вашего устройства специальное
свойство, которое покажет, какие GPIO использует ваше устройство:
\begin{lstlisting}
example {
	compatible = "spbau,example";
	out-gpios = <&gpio 24 0>;
};
\end{lstlisting}

Здесь мы добавили в к нашему устройству свойство \emph{out-gpio}. Имя свойства
имеет определенный формат, то что находится до символа \emph{"-"} называется
функцией. Предполагается, что эта часть должна описывать назначение GPIO. В
нашем случае мы будем выдавать на него сигнал, так что назвали его \emph{out}.
Далее идет слово \emph{gpios}, свойства заканчивающиеся на это слово
автоматически находятся подсистемой ядра Linux отвечающей за GPIO, т. е. оно
должно быть там всегда.

Далее идет описание используемого GPIO. С этим описанием все несколько сложнее
и мы опустим детали. В общих чертах \emph{\&gpio} - ссылка на устройство,
которое предоставляет нам доступ к GPIO\footnote{Его описание разбросано по
нескольким файлам, но сейчас нам важно знать, только то что оно есть и его имя
\emph{gpio}.}. Второй параметр, как не трудно догадаться задает номер GPIO.

Так как многие детали были опущены, полезно указать, где их искать. Свойства
DT используемые ядром Linux на различных устройствах, обычно, довольно хорошо
документированы. Общая информация касательно описания GPIO в DT доступна в файле
\emph{linux/Documentation/devicetree/bindings/gpio/gpio.txt} исходников ядра.

Теперь у нас есть описание используемого GPIO в DT, нужно только запустить
компиляцию ядра, чтобы собрать новый Device Tree Blob, а затем залить
обновленное ядро и Device Tree Blob на карту памяти.

Далее нам нужно научиться работать с GPIO в драйвере - это очень просто. Как и
в \emph{legacy} интерфейсе нам нужно сначала запросить нужный GPIO, но теперь мы
будем использовать вместо номера функцию. Функция нашего GPIO называется \emph{out},
соответственно ее и будем использовать при запросе GPIO. Чтобы запросить GPIO
используется функция \emph{gpiod\_get}. Обратите внимание, что в отличие от
\emph{legacy}, новый интерфейс использует префикс \emph{gpiod}, а не \emph{gpio}.
Когда вы закончите работу с GPIO, его нужно освободить используя функцию
\emph{gpiod\_put} - ничего сложного:
\begin{lstlisting}
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/printk.h>
#include <linux/init.h>

#include <linux/platform_device.h>
#include <linux/gpio/consumer.h>
#include <linux/of.h>

static struct gpio_desc *gpio;

static int example_probe(struct platform_device *pdev)
{
	gpio = gpiod_get(&pdev->dev, "out", GPIOD_OUT_HIGH);

	if (IS_ERR(gpio)) {
		pr_err("failed to acquire GPIO\n");
		return PTR_ERR(gpio);
	}
	return 0;
}

static int example_remove(struct platform_device *pdev)
{
	gpiod_put(gpio);
	return 0;
}

static const struct of_device_id example_of_ids[] = {
	{ .compatible = "spbau,example" },
	{ }
};

static struct platform_driver example = {
	.probe = &example_probe,
	.remove = &example_remove,
	.driver = {
		.name = "example",
		.owner = THIS_MODULE,
		.of_match_table = example_of_ids,
	},
};

MODULE_DEVICE_TABLE(of, example_of_ids);
module_platform_driver(example);
MODULE_LICENSE("GPL");
\end{lstlisting}

Третий параметр функции \emph{gpiod\_get} позволяет инициализировать GPIO в
какое-то начальное состояние. В данном примере, GPIO настраивается на выход и
на него сразу же подается сигнал. Таким образом, если вы все сделали правильно
то, если вы подключите светодиод к 24 GPIO, то он должен гореть.

Остальные функции для работы с GPIO остаются на самостоятельное изучение - вы
можете легко найти все что нужно в подключенных в примере заголовочных файлах
или используя \url{http://lxr.free-electrons.com/}.
